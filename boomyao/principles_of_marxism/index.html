<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é©¬å…‹æ€ä¸»ä¹‰åŸºæœ¬åŸç†é¢˜åº“</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js" crossorigin></script>
    <script src="https://unpkg.com/vue-router@4/dist/vue-router.global.prod.js" crossorigin></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="app" class="container">
        <header>
            <a href="/boomyao" class="back-button">â†</a>
            <h1>{{ $route.path === '/wrong' ? 'é”™é¢˜æœ¬' : 'é©¬å…‹æ€ä¸»ä¹‰åŸºæœ¬åŸç†é¢˜åº“' }}</h1>
        </header>
        <router-view></router-view>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, watch } = Vue;
        const { createRouter, createWebHashHistory } = VueRouter;

        // é¢˜åº“ç»„ä»¶
        const QuestionBank = {
            template: `
                <div>
                    <div v-if="currentQuestion" class="question-card">
                        <div class="question-header">
                            <span class="question-number">é¢˜ç›® {{ currentQuestionNumber }}</span>
                        </div>
                        <div class="question-title">{{ currentQuestion.title }}</div>
                        <div class="options">
                            <div v-for="item in currentQuestion.selectedItems" 
                                :key="item.ItemName"
                                class="option"
                                :class="{
                                    'selected': !showResult && userAnswer && userAnswer.selected === item.ItemName,
                                    'correct': (showResult || userAnswer) && item.ItemName === currentQuestion.answer,
                                    'wrong': (showResult || userAnswer) && userAnswer && userAnswer.selected === item.ItemName && item.ItemName !== currentQuestion.answer
                                }"
                                @click="selectAnswer(item.ItemName)">
                                {{ item.ItemName }}. {{ item.Content }}
                                <span class="option-result" :class="{ show: (showResult || userAnswer) && (item.ItemName === currentQuestion.answer || (userAnswer && userAnswer.selected === item.ItemName)) }">
                                    {{ item.ItemName === currentQuestion.answer ? 'âœ“' : 'âœ—' }}
                                </span>
                            </div>
                        </div>
                        <div class="explanation" :class="{ show: showResult || userAnswer }">
                            <div class="explanation-title">è§£æ</div>
                            <div class="explanation-content" v-html="formattedExplanation"></div>
                        </div>
                    </div>
                    <div class="nav-buttons">
                        <button class="nav-button" 
                                :disabled="currentQuestionNumber <= 1"
                                @click="prevQuestion">
                            â† ä¸Šä¸€é¢˜
                        </button>
                        <button class="nav-button" 
                                :disabled="currentQuestionNumber >= totalQuestions"
                                @click="nextQuestion">
                            ä¸‹ä¸€é¢˜ â†’
                        </button>
                    </div>
                </div>
            `,
            setup() {
                const currentQuestionNumber = ref(1);
                const totalQuestions = 683;
                const currentQuestion = ref(null);
                const userAnswers = ref({});
                const showResult = ref(false);
                const router = VueRouter.useRouter();

                const formattedExplanation = computed(() => {
                    if (!currentQuestion.value) return '';
                    return currentQuestion.value.explain
                        .replace(/\\n/g, '<br>')
                        .replace(/ğŸ“š/g, '<span class="emoji">ğŸ“š</span>')
                        .replace(/ğŸ”/g, '<span class="emoji">ğŸ”</span>')
                        .replace(/ğŸ’¡/g, '<span class="emoji">ğŸ’¡</span>');
                });

                const userAnswer = computed(() => {
                    return userAnswers.value[currentQuestionNumber.value];
                });

                const getStoragePrefix = () => {
                    const path = window.location.pathname;
                    const cleanPath = path.replace(/^\//, '').replace(/\/index\.html$/, '');
                    return cleanPath.replace(/\//g, '_') + '_';
                };

                const loadProgress = () => {
                    const urlParams = new URLSearchParams(window.location.hash.split('?')[1]);
                    const q = parseInt(urlParams.get('q'));
                    if (q && q > 0 && q <= totalQuestions) {
                        currentQuestionNumber.value = q;
                    } else {
                        const prefix = getStoragePrefix();
                        const savedProgress = localStorage.getItem(prefix + 'questionProgress');
                        if (savedProgress) {
                            currentQuestionNumber.value = parseInt(savedProgress);
                        }
                    }
                };

                const saveProgress = () => {
                    const prefix = getStoragePrefix();
                    localStorage.setItem(prefix + 'questionProgress', currentQuestionNumber.value.toString());
                    localStorage.setItem(prefix + 'userAnswers', JSON.stringify(userAnswers.value));
                    router.replace({ query: { q: currentQuestionNumber.value }});
                };

                const loadQuestion = async (questionNumber) => {
                    try {
                        const response = await fetch(`./questions/${questionNumber}.json`);
                        currentQuestion.value = await response.json();
                        showResult.value = false;
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                        saveProgress();
                    } catch (error) {
                        console.error('Error loading questions:', error);
                    }
                };

                const selectAnswer = (selectedOption) => {
                    if (showResult.value) return;
                    
                    const isCorrect = selectedOption === currentQuestion.value.answer;
                    userAnswers.value[currentQuestionNumber.value] = {
                        selected: selectedOption,
                        isCorrect: isCorrect,
                        timestamp: new Date().toISOString()
                    };
                    showResult.value = true;

                    // ä¿å­˜ç­”é¢˜è®°å½•
                    const prefix = getStoragePrefix();
                    localStorage.setItem(prefix + 'userAnswers', JSON.stringify(userAnswers.value));

                    // æ›´æ–°é”™é¢˜æœ¬
                    const savedWrongQuestions = localStorage.getItem(prefix + 'wrongQuestions');
                    let wrongQuestions = savedWrongQuestions ? JSON.parse(savedWrongQuestions) : [];
                    
                    if (!isCorrect && !wrongQuestions.includes(currentQuestionNumber.value)) {
                        wrongQuestions.push(currentQuestionNumber.value);
                        localStorage.setItem(prefix + 'wrongQuestions', JSON.stringify(wrongQuestions));
                    } else if (isCorrect) {
                        const index = wrongQuestions.indexOf(currentQuestionNumber.value);
                        if (index > -1) {
                            wrongQuestions.splice(index, 1);
                            localStorage.setItem(prefix + 'wrongQuestions', JSON.stringify(wrongQuestions));
                        }
                    }
                };

                const prevQuestion = () => {
                    if (currentQuestionNumber.value > 1) {
                        currentQuestionNumber.value--;
                    }
                };

                const nextQuestion = () => {
                    if (currentQuestionNumber.value < totalQuestions) {
                        currentQuestionNumber.value++;
                    }
                };

                watch(currentQuestionNumber, (newValue) => {
                    loadQuestion(newValue);
                });

                onMounted(() => {
                    loadProgress();
                    loadQuestion(currentQuestionNumber.value);
                });

                return {
                    currentQuestionNumber,
                    totalQuestions,
                    currentQuestion,
                    userAnswer,
                    showResult,
                    formattedExplanation,
                    selectAnswer,
                    prevQuestion,
                    nextQuestion
                };
            }
        };

        // é”™é¢˜æœ¬ç»„ä»¶
        const WrongQuestions = {
            template: `
                <div>
                    <div v-if="currentQuestion" class="question-card">
                        <div class="question-header">
                            <span class="question-number">é”™é¢˜ {{ currentIndex + 1 }}/{{ wrongQuestions.length }} (åŸé¢˜å·: {{ currentQuestion.id }})</span>
                        </div>
                        <div class="question-title">{{ currentQuestion.title }}</div>
                        <div class="options">
                            <div v-for="item in currentQuestion.selectedItems" 
                                :key="item.ItemName"
                                class="option"
                                :class="{
                                    'selected': !showResult && userAnswer && userAnswer.selected === item.ItemName,
                                    'correct': (showResult || userAnswer) && item.ItemName === currentQuestion.answer,
                                    'wrong': (showResult || userAnswer) && userAnswer && userAnswer.selected === item.ItemName && item.ItemName !== currentQuestion.answer
                                }"
                                @click="selectAnswer(item.ItemName)">
                                {{ item.ItemName }}. {{ item.Content }}
                                <span class="option-result" :class="{ show: (showResult || userAnswer) && (item.ItemName === currentQuestion.answer || (userAnswer && userAnswer.selected === item.ItemName)) }">
                                    {{ item.ItemName === currentQuestion.answer ? 'âœ“' : 'âœ—' }}
                                </span>
                            </div>
                        </div>
                        <div class="explanation" :class="{ show: showResult || userAnswer }">
                            <div class="explanation-title">è§£æ</div>
                            <div class="explanation-content" v-html="formattedExplanation"></div>
                        </div>
                    </div>
                    <div v-else-if="wrongQuestions.length === 0" style="text-align: center; padding: 2rem;">
                        <h2>æš‚æ— é”™é¢˜</h2>
                        <p style="margin-top: 1rem;">å»<router-link to="/" style="color: var(--secondary-color)">é¢˜åº“</router-link>åšé¢˜å§ï¼</p>
                    </div>
                    <div class="nav-buttons" v-if="wrongQuestions.length > 0">
                        <button class="nav-button" 
                                :disabled="currentIndex <= 0"
                                @click="prevQuestion">
                            â† ä¸Šä¸€é¢˜
                        </button>
                        <button class="nav-button" 
                                :disabled="currentIndex >= wrongQuestions.length - 1"
                                @click="nextQuestion">
                            ä¸‹ä¸€é¢˜ â†’
                        </button>
                    </div>
                </div>
            `,
            setup() {
                const currentIndex = ref(0);
                const wrongQuestions = ref([]);
                const currentQuestion = ref(null);
                const userAnswers = ref({});
                const showResult = ref(false);

                const formattedExplanation = computed(() => {
                    if (!currentQuestion.value) return '';
                    return currentQuestion.value.explain
                        .replace(/\\n/g, '<br>')
                        .replace(/ğŸ“š/g, '<span class="emoji">ğŸ“š</span>')
                        .replace(/ğŸ”/g, '<span class="emoji">ğŸ”</span>')
                        .replace(/ğŸ’¡/g, '<span class="emoji">ğŸ’¡</span>');
                });

                const userAnswer = computed(() => {
                    if (!currentQuestion.value) return null;
                    return userAnswers.value[currentQuestion.value.id];
                });

                const getStoragePrefix = () => {
                    const path = window.location.pathname;
                    const cleanPath = path.replace(/^\//, '').replace(/\/index\.html$/, '');
                    return cleanPath.replace(/\//g, '_') + '_';
                };

                const loadUserAnswers = () => {
                    const prefix = getStoragePrefix();
                    // ç›´æ¥ä»é”™é¢˜æœ¬å­˜å‚¨ä¸­åŠ è½½
                    const savedWrongQuestions = localStorage.getItem(prefix + 'wrongQuestions');
                    if (savedWrongQuestions) {
                        return JSON.parse(savedWrongQuestions);
                    }
                    
                    // å¦‚æœæ²¡æœ‰é”™é¢˜æœ¬è®°å½•ï¼Œåˆ™ä»ç­”é¢˜è®°å½•ä¸­åˆå§‹åŒ–
                    const savedAnswers = localStorage.getItem(prefix + 'userAnswers');
                    if (savedAnswers) {
                        const answers = JSON.parse(savedAnswers);
                        const wrongQuestionIds = Object.entries(answers)
                            .filter(([_, answer]) => !answer.isCorrect)
                            .map(([id]) => parseInt(id));
                        // åˆå§‹åŒ–é”™é¢˜æœ¬å­˜å‚¨
                        localStorage.setItem(prefix + 'wrongQuestions', JSON.stringify(wrongQuestionIds));
                        return wrongQuestionIds;
                    }
                    return [];
                };

                const loadQuestion = async (questionId) => {
                    try {
                        const response = await fetch(`./questions/${questionId}.json`);
                        const question = await response.json();
                        question.id = questionId; // ä¿å­˜åŸé¢˜å·
                        currentQuestion.value = question;
                        showResult.value = false;
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    } catch (error) {
                        console.error('Error loading question:', error);
                    }
                };

                const selectAnswer = (selectedOption) => {
                    if (showResult.value) return;
                    
                    const isCorrect = selectedOption === currentQuestion.value.answer;
                    userAnswers.value[currentQuestion.value.id] = {
                        selected: selectedOption,
                        isCorrect: isCorrect,
                        timestamp: new Date().toISOString()
                    };
                    showResult.value = true;

                    // ä¿å­˜ç­”é¢˜è®°å½•
                    const prefix = getStoragePrefix();
                    localStorage.setItem(prefix + 'userAnswers', JSON.stringify(userAnswers.value));

                    // å¦‚æœç­”é”™äº†ï¼Œç¡®ä¿é¢˜ç›®ä»åœ¨é”™é¢˜åˆ—è¡¨ä¸­
                    if (!isCorrect && !wrongQuestions.value.includes(currentQuestion.value.id)) {
                        wrongQuestions.value.push(currentQuestion.value.id);
                    }
                    // å¦‚æœç­”å¯¹äº†ï¼Œä»é”™é¢˜åˆ—è¡¨ä¸­ç§»é™¤
                    else if (isCorrect) {
                        const index = wrongQuestions.value.indexOf(currentQuestion.value.id);
                        if (index > -1) {
                            wrongQuestions.value.splice(index, 1);
                            // å¦‚æœå½“å‰é¢˜ç›®æ˜¯æœ€åä¸€ä¸ªé”™é¢˜ï¼Œè¿”å›åˆ°ä¸Šä¸€é¢˜
                            if (wrongQuestions.value.length === 0) {
                                currentQuestion.value = null;
                            } else if (currentIndex.value >= wrongQuestions.value.length) {
                                currentIndex.value = wrongQuestions.value.length - 1;
                            }
                        }
                    }

                    // ä¿å­˜é”™é¢˜åˆ—è¡¨
                    localStorage.setItem(prefix + 'wrongQuestions', JSON.stringify(wrongQuestions.value));
                };

                const prevQuestion = () => {
                    if (currentIndex.value > 0) {
                        currentIndex.value--;
                    }
                };

                const nextQuestion = () => {
                    if (currentIndex.value < wrongQuestions.value.length - 1) {
                        currentIndex.value++;
                    }
                };

                watch(currentIndex, (newValue) => {
                    if (wrongQuestions.value.length > 0) {
                        loadQuestion(wrongQuestions.value[newValue]);
                    }
                });

                onMounted(async () => {
                    const wrongQuestionIds = loadUserAnswers();
                    wrongQuestions.value = wrongQuestionIds;
                    
                    if (wrongQuestionIds.length > 0) {
                        await loadQuestion(wrongQuestionIds[0]);
                    }
                });

                return {
                    currentIndex,
                    wrongQuestions,
                    currentQuestion,
                    userAnswer,
                    showResult,
                    formattedExplanation,
                    selectAnswer,
                    prevQuestion,
                    nextQuestion
                };
            }
        };

        // åˆ›å»ºè·¯ç”±
        const router = createRouter({
            history: createWebHashHistory(),
            routes: [
                { path: '/', component: QuestionBank },
                { path: '/wrong', component: WrongQuestions }
            ]
        });

        // åˆ›å»ºåº”ç”¨
        const app = createApp({});
        app.use(router);
        app.mount('#app');
    </script>
</body>
</html> 